
import { NextRequest, NextResponse } from 'next/server'
import { verifyMessage } from 'ethers'
import { supabase } from '@/lib/supabase'
import { cookies } from 'next/headers'

const MESSAGE_TEMPLATE = "Sign this message to login to Banner Marketplace: "

export async function POST(request: NextRequest) {
    try {
        const { address, signature, nonce } = await request.json()

        if (!address || !signature || !nonce) {
            return NextResponse.json({ error: 'Missing parameters' }, { status: 400 })
        }

        // Verify signature
        // In a real app, nonce should be generated by server and checked. 
        // Here verifying the signature matches the address and message.
        const message = `${MESSAGE_TEMPLATE}${nonce}`
        const recoveredAddress = verifyMessage(message, signature)

        if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
            return NextResponse.json({ error: 'Invalid signature' }, { status: 401 })
        }

        // Check if user exists
        const { data: existingUser } = await supabase
            .from('users')
            .select('*')
            .eq('wallet_address', address)
            .single()

        let user = existingUser

        // Check for pending X auth
        const pendingXCookie = (await cookies()).get('x_auth_pending')
        let xData = null
        if (pendingXCookie) {
            try {
                xData = JSON.parse(pendingXCookie.value)
            } catch (e) {
                console.error("Failed to parse x_auth_pending cookie")
            }
        }

        if (!user) {
            // Create new user
            // If we have X data, use it.
            // Role: If X data is present, 'creator'? If not, 'advertiser'?
            // Prompt says: Creators connect X. Advertisers pay.
            // A user can be both?
            // Let's assume default is 'advertiser' unless X is connected.

            const role = xData ? 'creator' : 'advertiser'

            const insertData: any = {
                wallet_address: address,
                role,
            }

            if (xData) {
                insertData.x_user_id = xData.x_user_id
                insertData.encrypted_tokens = xData.encrypted_tokens
            }

            const { data: newUser, error } = await supabase
                .from('users')
                .insert(insertData)
                .select()
                .single()

            if (error) {
                console.error('Error creating user:', error)
                return NextResponse.json({ error: 'Failed to create user' }, { status: 500 })
            }
            user = newUser
        } else {
            // Update existing user with X data if present
            if (xData) {
                const { error } = await supabase
                    .from('users')
                    .update({
                        x_user_id: xData.x_user_id,
                        encrypted_tokens: xData.encrypted_tokens,
                        role: 'creator' // Upgrade to creator? Or keep existing?
                    })
                    .eq('id', user.id)

                if (error) {
                    console.error('Error linking X account:', error)
                    // Non-fatal?
                } else {
                    // Fetch updated
                    user.x_user_id = xData.x_user_id
                    user.role = 'creator'
                }
            }
        }

        // Set session cookie
        (await
            // Set session cookie
            cookies()).set('user_session', JSON.stringify({
            id: user.id,
            wallet_address: user.wallet_address,
            role: user.role
        }), {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            path: '/',
            maxAge: 60 * 60 * 24 * 7 // 1 week
        })

        // Clear pending cookie
        if (xData) {
            (await cookies()).delete('x_auth_pending')
        }

        return NextResponse.json({ success: true, user })

    } catch (error) {
        console.error('Wallet auth error:', error)
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
    }
}
